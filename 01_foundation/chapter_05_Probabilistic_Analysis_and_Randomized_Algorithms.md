
# 第5章&ensp;概率分析和随机算法

## 5.1&ensp;雇佣问题

### 5.1&ensp;练习

#### 5.1-1&ensp;证明

假设我们不知道一个应聘者i的排名，那么因为它以随机的一个顺序来应聘，所以就有可能出现他和应聘者best（也是随机的）无法比较的情况，所以我们必须知道任一应聘者i和随机出现的best之间的比较，即知道所有应聘者的排名。

#### 5.1-2&ensp;描述RANDOM的一种实现

根据时间生成：<br>
生成a~b之间的整数，相当于$a+\begin{equation*}\sum\limits_{1}^{b-a}RANDOM(0,1)\end{equation*}$<br>
如何生成RANDOM(0,1)，根据当前时间(戳)，如果是基数，则为0，如果是偶数则为1

#### 5.1-3&ensp;BIASED_RANDOM

1. 列表A0 = [0,1]作为初始数组，采用切片的方式返回要选择的数：br = BIASED_RANDOM(0,1),第一次返回0时，即A0[br]，列表变为A1 = [[0,1],1]，出现此种情况的概率为1-p；
2. 第2次，返回1，即A1[br1=0][br2=1]，或者A1[br1=1]，将列表变为A2 = [[0,1],[0,1]]，出现此种情况的概率为2p-p\*p；
1. 如此不断重复：结果为1，就在列表中补0，结果为0，就在列表中补1，补的时候保证0在每次切片的0位置即可，当n足够大，列表中0的期望个数为np，1的期望个数为n(1-p)，n+1次选择的时候，出现0的概率为np(1-p)，出现1的概率为n(1-p)p，二者相等。

## 5.2&ensp;指示器随机变量

### 5.2&ensp;练习

#### 5.2-1&ensp;求p(hire=1)、p(hire=n)

hire=1，即列表中最大的数出现在第一个位置，p(hire=1)=1/n<br>
hire=n，即列表中元素互补相同，且为顺序，p(hire=n)=1/(n\*n)

#### 5.2-2&ensp;求p(hire=2)

$p(hire=2)=\frac{2(n-2)}{n(n-1)}$<br>
一组互不相同的组成一个列表的情况有$n!$种<br>
只雇佣两次，又因为第一次必须雇佣，所以有以下两种情形：
1. 次大数在第一位，其它数任意放在后面，组成的列表情况有$(n-1)!$种<br>
2. 最大数在第二位，其它的数在任意位置，组成的列表情况有$(n-1)!-(n-2)!$种，其中当次大数在第一位，最大数在第二位时和情形1重复，故需要减掉

#### 5.2-3&ensp;用指示器随机变量求n个骰子之和的期望值

掷一个骰子点数出现的情况构成样本空间S={6，5，4，3，2，1}，对应的指示器随机变量$$I\{A\}=\begin{cases}
1/6，如果点数6朝上\\
1/6，如果点数5朝上\\
1/6，如果点数4朝上\\
1/6，如果点数3朝上\\
1/6，如果点数2朝上\\
1/6，如果点数1朝上\\
\end{cases}$$
掷一个骰子，点数期望值为$E[I\{A\}] = 3.5$<br>
掷n个骰子，点数和期望值为$E[n*I\{A\}] = nE[I\{A\}]=3.5n$

#### 5.2-4&ensp;拿到自己帽子的客户期望数

一个顾客拿到帽子的情况构成的样本空间S={1(拿到)，0(没拿到)}，对应的指示器随机变量
$$I\{A\}=\begin{cases}
1，拿到了自己的帽子\\
0，没拿到自己的帽子\\
\end{cases}$$
一个顾客拿到自己帽子的期望值为$E[I\{A\}] = \frac{1}{n}$<br>
n个顾客拿到自己帽子期望值为$E[n*I\{A\}] = n*E[I\{A\}]=1$

#### 5.2-5&ensp;逆序对数目

任取一个数A[i]，i为索引，1 <= i <= n，则A[i+1]与A[i]相比的结果构成样本空间S={1（大于），0（小于等于）}$$I\{A\}=\begin{cases}
1，大于\\
0，小于等于\\
\end{cases}$$对于i+1，它的逆序对数期望值为$E[I\{A\}]=0.5$<br>
对整个数组，逆序对数量的期望值为
$E[\begin{equation*}
\sum\limits_{i=1}^{n-1}(
\end{equation*}$
$\begin{equation*}
\sum\limits_{i+1}^{n}I\{A\})]
\end{equation*}
$=0.25\*n\*(n-1)

## 5.3&ensp;随机算法

### 5.3&ensp;练习

#### 5.3-1&ensp;Marceau教授

```
RANDOMIZE_IN_PLACE(A)
    n = A.length
    if n == 0
        return A
    else:
        for i = 1 to n
            swap A[i] with A[RANDOM(i,n)]
        return A
```

#### 5.3-2&ensp;Kelp教授

不能。因为对任意的i，A[i]处于i位置是不可能事件

#### 5.3-3&ensp;与数组任意位置交换

不会。举反例，当A[1]和A[1]交换后，A[2]再和A[1]交换后，A[2]这个数就丢失了

#### 5.3-4&ensp;Armstrong教授

因为offset的取值是random[0,1]，所以为1/n<br>
但是因为dest可能出现相同的值，举例：n=10，i=3，offset=8，dest=1，当i=4，offset=7时，dest=1，此时A[3]这个值就丢失了。
