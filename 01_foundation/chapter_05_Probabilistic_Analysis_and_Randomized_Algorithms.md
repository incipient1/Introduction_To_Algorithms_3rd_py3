
# 第5章&ensp;概率分析和随机算法

## 5.1&ensp;雇佣问题

### 5.1&ensp;练习

#### 5.1-1&ensp;证明

假设我们不知道一个应聘者i的排名，那么因为它以随机的一个顺序来应聘，所以就有可能出现他和应聘者best（也是随机的）无法比较的情况，所以我们必须知道任一应聘者i和随机出现的best之间的比较，即知道所有应聘者的排名。

#### 5.1-2&ensp;描述RANDOM的一种实现

根据时间生成：<br>
生成a~b之间的整数，相当于$a+\begin{equation*}\sum\limits_{1}^{b-a}RANDOM(0,1)\end{equation*}$<br>
如何生成RANDOM(0,1)，根据当前时间(戳)，如果是基数，则为0，如果是偶数则为1

#### 5.1-3&ensp;BIASED_RANDOM

1. 列表A0 = [0,1]作为初始数组，采用切片的方式返回要选择的数：br = BIASED_RANDOM(0,1),第一次返回0时，即A0[br]，列表变为A1 = [[0,1],1]，出现此种情况的概率为1-p；
2. 第2次，返回1，即A1[br1=0][br2=1]，或者A1[br1=1]，将列表变为A2 = [[0,1],[0,1]]，出现此种情况的概率为2p-p\*p；
1. 如此不断重复：结果为1，就在列表中补0，结果为0，就在列表中补1，补的时候保证0在每次切片的0位置即可，当n足够大，列表中0的期望个数为np，1的期望个数为n(1-p)，n+1次选择的时候，出现0的概率为np(1-p)，出现1的概率为n(1-p)p，二者相等。

## 5.2&ensp;指示器随机变量

### 5.2&ensp;练习

#### 5.2-1&ensp;求p(hire=1)、p(hire=n)

hire=1，即列表中最大的数出现在第一个位置，p(hire=1)=1/n<br>
hire=n，即列表中元素互补相同，且为顺序，p(hire=n)=1/(n\*n)

#### 5.2-2&ensp;求p(hire=2)

$p(hire=2)=\frac{2(n-2)}{n(n-1)}$<br>
一组互不相同的组成一个列表的情况有$n!$种<br>
只雇佣两次，又因为第一次必须雇佣，所以有以下两种情形：
1. 次大数在第一位，其它数任意放在后面，组成的列表情况有$(n-1)!$种<br>
2. 最大数在第二位，其它的数在任意位置，组成的列表情况有$(n-1)!-(n-2)!$种，其中当次大数在第一位，最大数在第二位时和情形1重复，故需要减掉

#### 5.2-3&ensp;用指示器随机变量求n个骰子之和的期望值

掷一个骰子点数出现的情况构成样本空间S={6，5，4，3，2，1}，对应的指示器随机变量$$I\{A\}=\begin{cases}
1/6，如果点数6朝上\\
1/6，如果点数5朝上\\
1/6，如果点数4朝上\\
1/6，如果点数3朝上\\
1/6，如果点数2朝上\\
1/6，如果点数1朝上\\
\end{cases}$$
掷一个骰子，点数期望值为$E[I\{A\}] = 3.5$<br>
掷n个骰子，点数和期望值为$E[n*I\{A\}] = nE[I\{A\}]=3.5n$

#### 5.2-4&ensp;拿到自己帽子的客户期望数

一个顾客拿到帽子的情况构成的样本空间S={1(拿到)，0(没拿到)}，对应的指示器随机变量
$$I\{A\}=\begin{cases}
1，拿到了自己的帽子\\
0，没拿到自己的帽子\\
\end{cases}$$
一个顾客拿到自己帽子的期望值为$E[I\{A\}] = \frac{1}{n}$<br>
n个顾客拿到自己帽子期望值为$E[n*I\{A\}] = n*E[I\{A\}]=1$

#### 5.2-5&ensp;逆序对数目

任取一个数A[i]，i为索引，1 <= i <= n，则A[i+1]与A[i]相比的结果构成样本空间S={1（大于），0（小于等于）}$$I\{A\}=\begin{cases}
1，大于\\
0，小于等于\\
\end{cases}$$对于i+1，它的逆序对数期望值为$E[I\{A\}]=0.5$<br>
对整个数组，逆序对数量的期望值为
$E[\begin{equation*}
\sum\limits_{i=1}^{n-1}(
\end{equation*}$
$\begin{equation*}
\sum\limits_{i+1}^{n}I\{A\})]
\end{equation*}
$=0.25\*n\*(n-1)

## 5.3&ensp;随机算法

### 5.3&ensp;练习

#### 5.3-1&ensp;Marceau教授

```
RANDOMIZE_IN_PLACE(A)
    n = A.length
    if n == 0
        return A
    else:
        for i = 1 to n
            swap A[i] with A[RANDOM(i,n)]
        return A
```

#### 5.3-2&ensp;Kelp教授

不能。因为对任意的i，A[i]处于i位置是不可能事件

#### 5.3-3&ensp;与数组任意位置交换

不会。举反例，当A[1]和A[1]交换后，A[2]再和A[1]交换后，A[2]这个数就丢失了

#### 5.3-4&ensp;Armstrong教授

因为offset的取值是random[0,1]，所以为1/n<br>
但是因为dest可能出现相同的值，举例：n=10，i=3，offset=8，dest=1，当i=4，offset=7时，dest=1，此时A[3]这个值就丢失了。

#### 5.3-5&ensp;所有元素都唯一的概率至少是

所有元素都唯一，即没有任何两个元素相同，此时数组一共有$A_n^k=\frac{n^{3}!}{(n^3-n)!}$种情况<br>
从(1,n^3)中任选元素组成的列表，一共有$n^{3n}$种情况，所以元素唯一的概率为$\frac{n^3!}{(n^3-n)!*n^{3n}}=\frac{n^3*(n^3-1)*...*(n^3-n+2)*(n^3-n+1)}{n^{3n}} \geqslant \frac{(n^3-n)^n}{n^{3n}} $，分子分母同时取对数,即$\geqslant \frac{log_n^{(n^3-n)^n}}{log_n^{n^{3n}}} = \frac{n^3-n}{n^3}=1-\frac{1}{n^2}\geqslant 1-\frac{1}{n}$,仅当n=1时等号成立

#### 5.3-6&ensp;优先级相同时生成均匀随机排列

问题关键在同优先级的排序这里，只要保证大小相等的数字排序时按照它们进入排序列表的前后顺序排列即可，所以生成的就是一个均匀随机排列。

#### 5.3-7&ensp;证明m子集等可能，random只调用m次

random调用m次，因为递归深度为m，每次的递归结束都会调用random<br>
每个元素被选中的概率是相等的，均为$\frac{1}{n-m}$现场v你们， 

## 5.4&ensp;概率分析和指示器随机变量

### 5.4&ensp;练习

#### 5.4-1&ensp;a：屋里有多少人，才能让某人和你生日相同的概率至少为1/2？b：必须要有多少人，至少两人生日为7月4日的概率大于1/2？

a：等于1减去所有人生日都和我不同的概率。我的生日占了1天，则其它人的生日可选364天，$(\frac{364}{365})^k \leqslant \frac{1}{2}$，k至少为253人(我不包含在内)<br>
b：等于1减去所有人生日都不在7月4日，减去仅1个人的生日在7月4日，$1-\frac{k}{365}(\frac{364}{365})^{k-1}-(\frac{364}{365})^{k} \geqslant \frac{1}{2}$，k至少为614

#### 5.4-2&ensp;投球次数期望

设投球次数为i，则任两个球在一个箱子里的概率为$\frac{i(i-1)(b-1)^{i-2}}{2b^{i-1}}$，需要让其大于等于1

#### 5.4-3&ensp;彼此独立or两两独立

须要求个人生日两两独立，否则同时发生的概率不等于各自发生概率相乘(公式5.6)

#### 5.4-4&ensp;三人生日可能相同

设需要有k人，三人生日相同：
$$P(3)=\frac{C_k^3*365*365^{k-3}}{365^k}=\frac{k(k-1)(k-2)}{365^2*6}$$
k >= 94
